<?php

namespace AvatarsAdorableIOPHP;

class AvatarsAdorableIO {
    const API_DOMAIN = 'https://api.adorable.io/';
    const API_ENDPOINT = 'avatars/';

    const API_RESOURCE_AUTO_GENERATE = '{size}/{input}';
    const API_RESOURCE_LIST = 'list';
    const API_RESOURCE_FACE = 'face/{eyes}/{nose}/{mouth}/{color}';

    private $feature_list = null;

    public function getValidSizes() {
    	return range(40, 285);
    }

    public function getAutoGenerated($size, $input) {
    	if (!isset($this->getValidSizes()[$size])) {
    		throw new \Exception('Invalid $size');
    	}

    	if (empty($input)) {
    		throw new \Exception('Invalid $input');
    	}

    	$url = $this->generateURL(self::API_RESOURCE_AUTO_GENERATE, ['{size}' => $size, '{input}' => $input]);

    	try {
    		return file_get_contents($url);
    	} catch (\Exception $e) {
    		throw $e;
    	}

    	return FALSE;
    }

    public function getAvatarFeaturesList() {
    	$url = $this->generateURL(self::API_RESOURCE_LIST);

    	$options = [];

    	try {
    		$request = $this->sendRequest($url, $options);
    		if (isset($request->data)) {
    			return $request->data;
    		}
    	} catch (\Exception $e) {
    		throw $e;
    	}

    	return FALSE;
    }

    public function getAvatarFace($eyes, $nose, $mouth, $color) {
    	if (empty($this->feature_list)) {
    		$this->feature_list = $this->getAvatarFeaturesList();
    	}

    	if (($isValidException = $this->isFeatureValid('eyes', $eyes)) === TRUE) {
    	} else {
    		throw $isValidException;
    	}

    	if (($isValidException = $this->isFeatureValid('nodes', $nose)) === TRUE) {
    	} else {
    		throw $isValidException;
    	}

    	if (($isValidException = $this->isFeatureValid('mouth', $mouth)) === TRUE) {
    	} else {
    		throw $isValidException;
    	}

    	if (($isValidException = $this->isFeatureValid('color', $color)) === TRUE) {
    	} else {
    		throw $isValidException;
    	}

    	$params = [
    		'eyes' => $eyes,
    		'nose' => $nose,
    		'mouth' => $mouth,
    		'color' => $color
    	];

    	$url = $this->generateURL(self::API_RESOURCE_FACE, $params);

    	try {
    		return file_get_contents($url);
    	} catch (\Exception $e) {
    		throw $e;
    	}
    }

    private function isFeatureValid($feature, $value) {
    	if (empty($value)) {
    		return new \Exception('$' . $feature . ' is empty');
    	}

    	if (!isset($this->feature_list->face->{$feature})) {
    		return new \Exception('$' . $feature . ' = ' . $feature . ' is invalid feature');
    	}

    	if (!isset($this->feature_list->face{$feature}->{$value})) {
    		return new \Exception('$' . $value . ' = ' . $value . ' is invalid feature value');
    	}

    	return TRUE;
    }

    private function generateURL($resource, $params = []) {
    	$url = self::API_DOMAIN . self::API_ENDPOINT . $resource;
    	foreach ($params as $param_key => $param_value) {
    		$url = str_replace($param_key, $param_value, $url);
    	}

    	return $url;
    }


    private function sendRequest($url, $options = array()) {
        $curl = curl_init();

        if (!isset($options['timeout'])) {
        	$options['timeout'] = 60;
        }

        if (isset($options['headers']) && !empty($options['headers'])) {
          $headers = $this->generateHeaders($options['headers']);
          curl_setopt($curl, CURLOPT_HEADER, FALSE);
          curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
        }
        if (isset($options['timeout'])) {
          curl_setopt($curl, CURLOPT_TIMEOUT, $options['timeout']);
        }
        $fields_string = '';
        if (isset($options['data'])) {
          if (isset($options['method']) && strtolower($options['method']) == 'get') {
            $fields_string = http_build_query($options['data']);
          } else {
            $fields_string = $options['data'];
          }
        }
        if (isset($options['method']) && strtolower($options['method']) == 'post') {
          curl_setopt($curl, CURLOPT_POST, TRUE);
          curl_setopt($curl, CURLOPT_POSTFIELDS, $fields_string);
        } else {
          $url .= '?' . $fields_string;
        }
        curl_setopt($curl, CURLOPT_URL, $url);
        $ua = 'AvatarsAdorableIO';
        curl_setopt($curl, CURLOPT_USERAGENT, $ua);
        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
        curl_setopt($curl, CURLOPT_FORBID_REUSE, TRUE);
        curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, $options['timeout']);
        curl_setopt($curl, CURLOPT_DNS_CACHE_TIMEOUT, 10);
        curl_setopt($curl, CURLOPT_FRESH_CONNECT, TRUE);
        $return = new \stdClass;
        try {
          $return_str = curl_exec($curl);
          $status = curl_getinfo($curl, CURLINFO_HTTP_CODE);
          curl_close($curl);
          $return->status_message = 'OK';
          $return->data = json_decode($return_str);
          if ($status >= 400) {
            $return->status_message = 'NOT OK';
            $return->code = $status;
            $return->error = $return_str;
          }
        } catch (\Exception $e) {
          $return->status_message = 'NOT OK';
          $return->data = json_encode(array(
            'code' => $e->getCode(),
            'message' => $e->getMessage(),
          ));
          $return->code = 400;
          $return->error = 'Unhandled error on request.';
        }
        return $return;
    }

    private function generateHeaders($headers) {
      $return = array();
      foreach($headers as $key => $value) {
        $return[] = $key . ': ' . $value;
      }
      return $return;
    }
}
